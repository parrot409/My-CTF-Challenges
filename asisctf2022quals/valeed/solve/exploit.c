#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <linux/audit.h>
#include <linux/filter.h>
#include <linux/seccomp.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/un.h>
#include <unistd.h>

#define errExit(msg)    \
  do {                  \
    perror(msg);        \
    exit(EXIT_FAILURE); \
  } while (0)

/* Send the file descriptor 'fd' over the connected UNIX domain socket
  'sockfd'. Returns 0 on success, or -1 on error. */

static int sendfd(int sockfd, int fd) {
  struct msghdr msgh;
  struct iovec iov;
  int data;
  struct cmsghdr *cmsgp;

  /* Allocate a char array of suitable size to hold the ancillary data.
     However, since this buffer is in reality a 'struct cmsghdr', use a
     union to ensure that it is suitably aligned. */
  union {
    char buf[CMSG_SPACE(sizeof(int))];
    /* Space large enough to hold an 'int' */
    struct cmsghdr align;
  } controlMsg;

  /* The 'msg_name' field can be used to specify the address of the
     destination socket when sending a datagram. However, we do not
     need to use this field because 'sockfd' is a connected socket. */

  msgh.msg_name = NULL;
  msgh.msg_namelen = 0;

  /* On Linux, we must transmit at least one byte of real data in
     order to send ancillary data. We transmit an arbitrary integer
     whose value is ignored by recvfd(). */

  msgh.msg_iov = &iov;
  msgh.msg_iovlen = 1;
  iov.iov_base = &data;
  iov.iov_len = sizeof(int);
  data = 12345;

  /* Set 'msghdr' fields that describe ancillary data */

  msgh.msg_control = controlMsg.buf;
  msgh.msg_controllen = sizeof(controlMsg.buf);

  /* Set up ancillary data describing file descriptor to send */

  cmsgp = CMSG_FIRSTHDR(&msgh);
  cmsgp->cmsg_level = SOL_SOCKET;
  cmsgp->cmsg_type = SCM_RIGHTS;
  cmsgp->cmsg_len = CMSG_LEN(sizeof(int));
  memcpy(CMSG_DATA(cmsgp), &fd, sizeof(int));

  /* Send real plus ancillary data */

  if (sendmsg(sockfd, &msgh, 0) == -1) return -1;

  return 0;
}

/* Receive a file descriptor on a connected UNIX domain socket. Returns
  the received file descriptor on success, or -1 on error. */

static int recvfd(int sockfd) {
  struct msghdr msgh;
  struct iovec iov;
  int data, fd;
  ssize_t nr;

  /* Allocate a char buffer for the ancillary data. See the comments
     in sendfd() */
  union {
    char buf[CMSG_SPACE(sizeof(int))];
    struct cmsghdr align;
  } controlMsg;
  struct cmsghdr *cmsgp;

  /* The 'msg_name' field can be used to obtain the address of the
     sending socket. However, we do not need this information. */

  msgh.msg_name = NULL;
  msgh.msg_namelen = 0;

  /* Specify buffer for receiving real data */

  msgh.msg_iov = &iov;
  msgh.msg_iovlen = 1;
  iov.iov_base = &data; /* Real data is an 'int' */
  iov.iov_len = sizeof(int);

  /* Set 'msghdr' fields that describe ancillary data */

  msgh.msg_control = controlMsg.buf;
  msgh.msg_controllen = sizeof(controlMsg.buf);

  /* Receive real plus ancillary data; real data is ignored */

  nr = recvmsg(sockfd, &msgh, 0);
  if (nr == -1) return -1;

  cmsgp = CMSG_FIRSTHDR(&msgh);

  /* Check the validity of the 'cmsghdr' */

  if (cmsgp == NULL || cmsgp->cmsg_len != CMSG_LEN(sizeof(int)) ||
      cmsgp->cmsg_level != SOL_SOCKET || cmsgp->cmsg_type != SCM_RIGHTS) {
    errno = EINVAL;
    return -1;
  }

  /* Return the received file descriptor to our caller */

  memcpy(&fd, CMSG_DATA(cmsgp), sizeof(int));
  return fd;
}

static void sigchldHandler(int sig) {
  // char msg[] = "\tS: target has terminated; bye\n";

  // write(STDOUT_FILENO, msg, sizeof(msg) - 1);
  puts("Child exited");
  _exit(EXIT_SUCCESS);
}

static int seccomp(unsigned int operation, unsigned int flags, void *args) {
  return syscall(__NR_seccomp, operation, flags, args);
}

#define X32_SYSCALL_BIT 0x40000000

#define X86_64_CHECK_ARCH_AND_LOAD_SYSCALL_NR                                  \
  BPF_STMT(BPF_LD | BPF_W | BPF_ABS, (offsetof(struct seccomp_data, arch))),   \
      BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, AUDIT_ARCH_X86_64, 0, 2),            \
      BPF_STMT(BPF_LD | BPF_W | BPF_ABS, (offsetof(struct seccomp_data, nr))), \
      BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, X32_SYSCALL_BIT, 0, 1),              \
      BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS)

static int installNotifyFilter(void) {
  struct sock_filter filter[] = {
      X86_64_CHECK_ARCH_AND_LOAD_SYSCALL_NR,

      BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_openat, 0, 1),
      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_USER_NOTIF),

      BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
  };

  struct sock_fprog prog = {
      .len = sizeof(filter) / sizeof(filter[0]),
      .filter = filter,
  };

  int notifyFd =
      seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_NEW_LISTENER, &prog);
  if (notifyFd == -1) errExit("seccomp-install-notify-filter");

  return notifyFd;
}

static void closeSocketPair(int sockPair[2]) {
  if (close(sockPair[0]) == -1) errExit("closeSocketPair-close-0");
  if (close(sockPair[1]) == -1) errExit("closeSocketPair-close-1");
}

static pid_t targetProcess(int sockPair[2], char *argv[]) {
  pid_t targetPid = fork();
  if (targetPid == -1) errExit("fork");

  if (targetPid > 0) /* In parent, return PID of child */
    return targetPid;

  if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) errExit("prctl");

  int notifyFd = installNotifyFilter();

  if (sendfd(sockPair[0], notifyFd) == -1) errExit("sendfd");

  /* Notification and socket FDs are no longer needed in target */

  if (close(notifyFd) == -1) errExit("close-target-notify-fd");

  closeSocketPair(sockPair);

  /* Perform a mkdir() call for each of the command-line arguments */
  puts("Executing child");
  sleep(1);
  char *f = NULL;
  execve("/home/pwn/readme", &f, &f);
  // openat(AT_FDCWD,"/bin/bash",0);
  exit(EXIT_SUCCESS);
}

static void allocSeccompNotifBuffers(struct seccomp_notif **req,
                                     struct seccomp_notif_resp **resp,
                                     struct seccomp_notif_sizes *sizes) {
  if (seccomp(SECCOMP_GET_NOTIF_SIZES, 0, sizes) == -1)
    errExit("seccomp-SECCOMP_GET_NOTIF_SIZES");

  *req = malloc(sizes->seccomp_notif);
  if (*req == NULL) errExit("malloc-seccomp_notif");

  size_t resp_size = sizes->seccomp_notif_resp;
  if (sizeof(struct seccomp_notif_resp) > resp_size)
    resp_size = sizeof(struct seccomp_notif_resp);

  *resp = malloc(resp_size);
  if (resp == NULL) errExit("malloc-seccomp_notif_resp");
}


static void handleNotifications(int notifyFd) {
  struct seccomp_notif_sizes sizes;
  struct seccomp_notif *req;
  struct seccomp_notif_resp *resp;
  char path[PATH_MAX];

  allocSeccompNotifBuffers(&req, &resp, &sizes);

  /* Loop handling notifications */

  for (;;) {
    /* Wait for next notification, returning info in '*req' */

    memset(req, 0, sizes.seccomp_notif);
    if (ioctl(notifyFd, SECCOMP_IOCTL_NOTIF_RECV, req) == -1) {
      if (errno == EINTR) continue;
      errExit("\tS: ioctl-SECCOMP_IOCTL_NOTIF_RECV");
    }

    if (req->data.nr != __NR_openat) {
      printf(
          "\tS: notification contained unexpected "
          "system call number; bye!!!\n");
      exit(EXIT_FAILURE);
    }

    struct seccomp_notif_addfd addfd;
    addfd.id = req->id; /* Cookie from SECCOMP_IOCTL_NOTIF_RECV */
    addfd.srcfd = openat(req->data.args[0], "/tmp/payload", req->data.args[2],req->data.args[3]);
    addfd.newfd = 3;
    addfd.flags = SECCOMP_ADDFD_FLAG_SETFD;
    addfd.newfd_flags = 0;
    int a2 = ioctl(notifyFd, SECCOMP_IOCTL_NOTIF_ADDFD, &addfd);

    resp->id = req->id;
    resp->flags = 0;
    resp->val = 0;
    resp->error = resp->val = 0;
    resp->val = a2;

    resp->flags = 0;

    if (ioctl(notifyFd, SECCOMP_IOCTL_NOTIF_SEND, resp) == -1) {
      if (errno == ENOENT)
        printf(
            "\tS: response failed with ENOENT; "
            "perhaps target process's syscall was "
            "interrupted by a signal?\n");
      else
        perror("ioctl-SECCOMP_IOCTL_NOTIF_SEND");
    }
  }

  free(req);
  free(resp);
  exit(EXIT_FAILURE);
}

/* Implementation of the supervisor process:

  (1) obtains the notification file descriptor from 'sockPair[1]'
  (2) handles notifications that arrive on that file descriptor. */

static void supervisor(int sockPair[2]) {
  int notifyFd = recvfd(sockPair[1]);
  if (notifyFd == -1) errExit("recvfd");

  closeSocketPair(sockPair); /* We no longer need the socket pair */

  handleNotifications(notifyFd);
}

void readBinary(){
  int sz,readed;
  printf("size:");
  scanf("%d",&sz);
  char *buf = malloc(sz);

  int f = open("/tmp/payload",O_WRONLY|O_CREAT,0777);
  while(sz > 0){
    readed = read(0,buf,sz);
    write(f,buf,readed);
    sz -= readed;
  }
}

int main(int argc, char *argv[]) {
  int sockPair[2];

  setbuf(stdout, NULL);
  readBinary();
  if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockPair) == -1)
    errExit("socketpair");

  struct sigaction sa;
  sa.sa_handler = sigchldHandler;
  sa.sa_flags = 0;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGCHLD, &sa, NULL) == -1) errExit("sigaction");
  targetProcess(sockPair, &argv[optind]);

  supervisor(sockPair);

  exit(EXIT_SUCCESS);
}
